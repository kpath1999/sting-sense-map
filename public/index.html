<!DOCTYPE html>
<html>
<head>
    <title>Bus Route Driving Behavior Analysis</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <style>
        body { margin: 0; padding: 0; }
        #map { height: 100vh; width: 100vw; }
        .leaflet-control-layers {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            position: absolute !important;
            top: 20px !important;
            right: 10px !important;
            z-index: 1000;
            min-width: 180px;
        }
        .leaflet-control-layers-base label, .leaflet-control-layers-overlays label {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .leaflet-control-layers span[style*="background-color"] {
            margin-right: 10px;
        }
        /* Enhanced popup styling */
        .leaflet-popup-content {
            margin: 8px 12px;
            line-height: 1.4;
            font-size: 13px;
            font-family: Arial, sans-serif;
        }
        .popup-section {
            margin-bottom: 12px;
        }
        .popup-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 6px;
            padding-bottom: 3px;
            border-bottom: 1px solid #ddd;
        }
        .data-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        .data-label {
            font-weight: 500;
            color: #555;
        }
        .data-value {
            color: #333;
            font-family: 'Courier New', monospace;
        }
        .highlight-value {
            background-color: #f0f8ff;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        .behavior-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
        }
        /* Query interface styles */
        .query-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1100;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            background-color: rgba(25, 57, 90, 0.92);
            border-radius: 12px;
            box-shadow: 0 4px 14px rgba(0,0,0,0.25);
            max-width: 760px;
            width: calc(100% - 40px);
        }
        .query-container input {
            flex: 1 1 260px;
            min-width: 200px;
            padding: 9px 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            outline: none;
            background: rgba(255,255,255,0.95);
            color: #1a2a3a;
        }
        .query-container button {
            padding: 9px 18px;
            background-color: #1f7acb;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.3px;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .query-container button:hover {
            background-color: #1660a0;
            transform: translateY(-1px);
        }
        .mode-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #e6f0ff;
            font-size: 12px;
            white-space: nowrap;
        }
        .mode-toggle-label {
            font-weight: 600;
            letter-spacing: 0.2px;
        }
        .toggle-switch {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 0;
            padding: 3px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.35);
            background: rgba(12, 34, 54, 0.55);
            cursor: pointer;
            min-width: 120px;
            transition: background 0.3s ease;
        }
        .toggle-switch:focus-visible {
            outline: 2px solid rgba(255,255,255,0.8);
            outline-offset: 3px;
        }
        .toggle-switch-option {
            flex: 1;
            text-align: center;
            font-weight: 600;
            font-size: 11px;
            position: relative;
            z-index: 2;
            color: rgba(255,255,255,0.7);
            transition: color 0.3s ease;
            padding: 5px 8px;
            min-width: 0;
        }
        .toggle-switch-option[data-role="cluster"] {
            padding-left: 2px;
        }
        .toggle-switch-option[data-role="raw"] {
            padding-right: 15px;
        }
        .toggle-switch-indicator {
            position: absolute;
            top: 3px;
            bottom: 3px;
            left: 3px;
            width: calc(50% - 3px);
            border-radius: 999px;
            background: #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: left 0.3s ease;
            z-index: 1;
        }
        .toggle-switch[data-mode="raw"] .toggle-switch-indicator {
            left: calc(50%);
        }
        .toggle-switch[data-mode="cluster"] .toggle-switch-option[data-role="cluster"],
        .toggle-switch[data-mode="raw"] .toggle-switch-option[data-role="raw"] {
            color: #0d2c4a;
            font-weight: 700;
        }
        .summary-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1001;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        .summary-content {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        .summary-header {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c7bb6;
            border-bottom: 2px solid #2c7bb6;
            padding-bottom: 10px;
        }
        .summary-section {
            margin-bottom: 20px;
        }
        .summary-section h3 {
            color: #555;
            margin-bottom: 10px;
        }
        .loading-message {
            color: #1a5f8c;
            font-weight: 600;
        }
        .error-message {
            color: #d7191c;
            background-color: #fbeaea;
            padding: 10px;
            border-radius: 6px;
        }
        .results {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .response-content {
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.5;
        }
        .feedback {
            display: flex;
            gap: 10px;
            align-items: center;
            font-size: 13px;
            color: #555;
        }
        .feedback-btn {
            padding: 6px 12px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #fff;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .feedback-btn:hover {
            background-color: #f0f0f0;
        }
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
        }
        .close-button:hover {
            color: #333;
        }
        @media (max-width: 640px) {
            .query-container {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            .mode-toggle {
                justify-content: space-between;
                width: 100%;
            }
            .toggle-switch {
                width: 100%;
            }
            .query-container input,
            .query-container button {
                width: 100%;
            }
        }
    </style>
</head>
<body>

<div id="map"></div>
<div class="query-container">
    <div class="mode-toggle">
        <span class="mode-toggle-label">Context</span>
        <button type="button" id="context-toggle" class="toggle-switch" data-mode="cluster" aria-pressed="false" aria-label="Context mode: Cluster">
            <span class="toggle-switch-indicator"></span>
            <span class="toggle-switch-option" data-role="cluster">Cluster</span>
            <span class="toggle-switch-option" data-role="raw">Raw</span>
        </button>
        <input type="hidden" id="context-mode" value="cluster" />
    </div>
    <input type="text" id="user-query" placeholder="Ask about driver patterns, dwell times, etc." aria-label="Enter analysis question" />
    <button id="submit-query">Ask</button>
</div>
<div class="modal-overlay" id="modalOverlay"></div>
<div class="summary-modal" id="summaryModal">
    <button class="close-button" onclick="closeSummary()">&times;</button>
    <div class="summary-content" id="summaryContent">
        <div class="summary-header" id="summaryHeader">Route Analysis Summary</div>
        <div id="summaryText">Enter a query to begin your analysis.</div>
        <div id="feedbackContainer"></div>
    </div>
</div>

<script>
    var map = L.map('map').setView([33.776, -84.389], 15);
    var allData = []; // Store all data points for analysis

    const promptTemplates = {
    aggressivePatterns: `You are a transportation safety analyst. Given the following summary of aggressive driving evidence, explain the underlying patterns in plain language, cite the campus locations, and recommend one follow-up analysis. Reply in plain text with no markdown, bullets, headings, or special characters, and keep it under 180 words.\n\nDATA SUMMARY:\n{{data}}\n\nUSER QUESTION: {{userQuery}}`,
    raw: `You are a transportation analyst. You will receive the entire bus telemetry dataset as raw JSON without any preprocessing. Use it to answer the user's question directly, pointing to concrete observations. Respond in plain text only—do not use markdown formatting, bullet points, or special characters—and keep your reply under 200 words.\n\nRAW DATASET (JSON):\n{{data}}\n\nUSER QUESTION: {{userQuery}}`,
    rawChunk: `You are a transportation analyst reviewing bus telemetry part {{chunkIndex}} of {{totalChunks}}. The data is raw JSON with no preprocessing. Extract concrete observations (locations, timestamps, behaviors) relevant to the user question. Write in plain text with no markdown, lists, or special characters, keep your response under 120 words, note any potential safety concerns, and focus only on this chunk.\n\nRAW DATA CHUNK:\n{{data}}\n\nUSER QUESTION: {{userQuery}}`,
    rawFinal: `You previously reviewed {{chunkCount}} raw telemetry chunks. Combine the analyst notes below into one cohesive answer for the user. Reference the question directly, call out specific patterns or anomalies, and keep the response under 220 words. Produce plain text only—no markdown formatting, bullets, or special characters. {{truncatedNote}}\n\nANALYST NOTES:\n{{data}}\n\nUSER QUESTION: {{userQuery}}`,
    dwellTime: `You are an operations planner studying bus dwell times. Interpret the campus dwell indicators below, connect them to possible rider or traffic causes, and outline one actionable optimization. Reference the places mentioned. Answer in plain text with no markdown, bullet points, or headings, and limit to 180 words.\n\nDATA SUMMARY:\n{{data}}\n\nUSER QUESTION: {{userQuery}}`,
    routeEfficiency: `You are a route efficiency specialist. Review the distance and timing insights below, assess how efficiently the bus moved through campus, and highlight any detours or slow legs in under 180 words. Use plain text only—no markdown formatting, lists, or special symbols.\n\nDATA SUMMARY:\n{{data}}\n\nUSER QUESTION: {{userQuery}}`,
    generalInfo: `You are writing a narrative briefing for campus transportation leadership. Summarize the key takeaways from the data below and directly address the user question in 180 words or less. Respond in plain text with no markdown, lists, or special characters.\n\nDATA SUMMARY:\n{{data}}\n\nUSER QUESTION: {{userQuery}}`
    };

    const RAW_SINGLE_REQUEST_CHAR_LIMIT = 11000;  // Legacy - deprecated
    const RAW_MAX_CHUNKS = 5;  // Legacy - deprecated
    const TOKENS_PER_CHAR_ESTIMATE = 0.25;  // rough estimate: 4 chars ~ 1 token
    const MAX_CONTEXT_TOKENS = 100000;  // Conservative estimate for Llama 4 Scout (actual is ~131K)
    const MAX_INPUT_TOKENS = MAX_CONTEXT_TOKENS - 2000;  // Reserve tokens for prompt template and output

    function analyzeUserQuery(query) {
        const normalized = query.toLowerCase();
        const queryTypes = {
            aggressivePatterns: ['aggressive', 'dangerous', 'speeding', 'harsh', 'reckless', 'behavior', 'pattern'],
            dwellTime: ['dwell', 'stop', 'wait', 'idle', 'stationary', 'linger', 'pause'],
            routeEfficiency: ['route', 'path', 'efficiency', 'detour', 'time', 'distance', 'slow', 'fast'],
            generalInfo: ['summary', 'overview', 'information', 'stats', 'insight', 'analysis']
        };

        const scores = Object.entries(queryTypes).map(([category, keywords]) => {
            const score = keywords.reduce((total, keyword) => total + (normalized.includes(keyword) ? 1 : 0), 0);
            return { category, score };
        });

        scores.sort((a, b) => b.score - a.score);
        return scores[0].score > 0 ? scores[0] : { category: 'generalInfo', score: 0 };
    }

    function getSelectedContextMode() {
        const modeField = document.getElementById('context-mode');
        return modeField ? modeField.value : 'cluster';
    }

    function escapeHtml(text) {
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    function optimizeFeatureForRawMode(feature) {
        // extract only the properties we need, rename for brevity
        const props = feature.properties;
        const [lon, lat] = feature.geometry.coordinates;

        return {
            b: props.behavior,
            t: props.timestamp,
            c: [lat, lon],
            i: props.instability_score,
            cl: props.cluster,
            a: {
                m: props.accel_mean,
                x99: props.accel_stats_x_p99,
                y99: props.accel_stats_y_p99,
                z99: props.accel_stats_z_p99
            }
        };
    }

    function compressDataset(features) {
        // including a legend for property names, helping the model understand
        const legend = {
            b: "behavior",
            t: "timestamp",
            c: "coordinates [lat, lon]",
            i: "instability_score",
            cl: "cluster",
            a: {
                m: "accel_mean",
                x99: "accel_stats_x_p99",
                y99: "accel_stats_y_p99",
                z99: "accel_stats_z_p99"
            }
        };

        // map the features to an optimized format
        const optimizedFeatures = features.map(optimizeFeatureForRawMode);

        return { legend, data: optimizedFeatures };
    }

    function splitFeaturesForRawMode(features) {
        // Step 1: Optimize/compress the entire dataset
        const compressedData = compressDataset(features);
        
        // Step 2: Calculate total estimated tokens
        const dataString = JSON.stringify(compressedData);
        const estimatedTokens = dataString.length * TOKENS_PER_CHAR_ESTIMATE;
        
        // Step 3: If it fits in one request, don't split at all
        if (estimatedTokens <= MAX_INPUT_TOKENS) {
            return {
                chunks: [{
                    data: compressedData,
                    startIndex: 0,
                    endIndex: features.length - 1,
                    estimatedTokens
                }],
                truncated: false,
                processedCount: features.length
            };
        }
        
        // Step 4: Calculate how many features per chunk
        const tokensPerFeature = estimatedTokens / features.length;
        const featuresPerChunk = Math.floor(MAX_INPUT_TOKENS / tokensPerFeature);
        
        // Step 5: Split the dataset into appropriately sized chunks
        const result = [];
        let startIndex = 0;
        let processed = 0;
        
        while (startIndex < features.length) {
            const endIndex = Math.min(startIndex + featuresPerChunk - 1, features.length - 1);
            const chunkFeatures = features.slice(startIndex, endIndex + 1);
            const chunkData = compressDataset(chunkFeatures);
            const chunkString = JSON.stringify(chunkData);
            
            result.push({
                data: chunkData,
                startIndex,
                endIndex,
                estimatedTokens: chunkString.length * TOKENS_PER_CHAR_ESTIMATE
            });
            
            processed = endIndex + 1;
            startIndex = endIndex + 1;
            
            // Safety check to prevent infinite loops
            if (result.length > 20) {
                console.warn('Exceeded maximum number of chunks (20)');
                break;
            }
        }
        
        return {
            chunks: result,
            truncated: processed < features.length,
            processedCount: processed
        };
    }

    function getTimeRangeSummary() {
        if (!allData.length) {
            return null;
        }
        const sorted = [...allData].sort((a, b) => new Date(a.properties.timestamp) - new Date(b.properties.timestamp));
        const start = new Date(sorted[0].properties.timestamp);
        const end = new Date(sorted[sorted.length - 1].properties.timestamp);
        const durationMinutes = Math.round((end - start) / 60000);
        return {
            startISO: start.toISOString(),
            endISO: end.toISOString(),
            durationMinutes
        };
    }

    function getBehaviorDistribution() {
        return allData.reduce((acc, feature) => {
            const behavior = feature.properties.behavior || 'Unknown';
            acc[behavior] = (acc[behavior] || 0) + 1;
            return acc;
        }, {});
    }

    function computeAggressiveHotspots() {
        const aggressiveEvents = allData.filter(feature => ['Aggressive', 'Very Aggressive'].includes(feature.properties.behavior));
        const clusters = aggressiveEvents.reduce((acc, feature) => {
            const clusterId = feature.properties.cluster ?? 'unclustered';
            if (!acc[clusterId]) {
                acc[clusterId] = {
                    points: [],
                    instability: 0
                };
            }
            acc[clusterId].points.push(feature);
            acc[clusterId].instability += feature.properties.instability_score || 0;
            return acc;
        }, {});

        return Object.entries(clusters).map(([clusterId, data]) => {
            const representative = data.points[0];
            const [lon, lat] = representative.geometry.coordinates;
            const locationContext = getEnhancedLocationContext(lat, lon);
            return {
                clusterId,
                events: data.points.length,
                averageInstability: Number((data.instability / data.points.length).toFixed(3)),
                location: locationContext.description,
                behaviorBreakdown: data.points.reduce((acc, feature) => {
                    const behavior = feature.properties.behavior;
                    acc[behavior] = (acc[behavior] || 0) + 1;
                    return acc;
                }, {})
            };
        }).sort((a, b) => (b.averageInstability * b.events) - (a.averageInstability * a.events)).slice(0, 5);
    }

    function computeDwellIndicators(sortedData) {
        const dwellIndicators = [];
        for (let i = 1; i < sortedData.length; i++) {
            const current = sortedData[i];
            const previous = sortedData[i - 1];
            const currentTime = new Date(current.properties.timestamp);
            const previousTime = new Date(previous.properties.timestamp);
            const gapMs = currentTime - previousTime;
            if (gapMs >= 120000) { // 2 minutes or more
                const [prevLon, prevLat] = previous.geometry.coordinates;
                const context = getEnhancedLocationContext(prevLat, prevLon);
                dwellIndicators.push({
                    durationMinutes: Number((gapMs / 60000).toFixed(1)),
                    resumedBehavior: current.properties.behavior,
                    location: context.description,
                    timestamp: previous.properties.timestamp
                });
            }
        }
        return dwellIndicators.slice(0, 5);
    }

    function computeRouteEfficiency(sortedData) {
        if (sortedData.length < 2) {
            return null;
        }
        let traveledDistance = 0;
        for (let i = 1; i < sortedData.length; i++) {
            const [prevLon, prevLat] = sortedData[i - 1].geometry.coordinates;
            const [lon, lat] = sortedData[i].geometry.coordinates;
            traveledDistance += getDistance(prevLat, prevLon, lat, lon);
        }
        const [startLon, startLat] = sortedData[0].geometry.coordinates;
        const [endLon, endLat] = sortedData[sortedData.length - 1].geometry.coordinates;
        const straightLine = getDistance(startLat, startLon, endLat, endLon);
        const efficiencyRatio = straightLine === 0 ? 1 : straightLine / traveledDistance;
        return {
            traveledDistanceMetres: Math.round(traveledDistance),
            straightLineMetres: Math.round(straightLine),
            efficiencyRatio: Number(efficiencyRatio.toFixed(3)),
            startLocation: getEnhancedLocationContext(startLat, startLon).description,
            endLocation: getEnhancedLocationContext(endLat, endLon).description
        };
    }

    async function fetchRelevantData(category) {
        if (!allData.length) {
            return { status: 'empty', message: 'No route data is loaded yet.' };
        }

        const sortedData = [...allData].sort((a, b) => new Date(a.properties.timestamp) - new Date(b.properties.timestamp));
        const timeRange = getTimeRangeSummary();
        const behaviorDistribution = getBehaviorDistribution();

        const base = {
            totalEvents: allData.length,
            timeRange,
            behaviorDistribution
        };

        switch (category) {
            case 'aggressivePatterns':
                return {
                    base,
                    aggressiveHotspots: computeAggressiveHotspots()
                };
            case 'dwellTime':
                return {
                    base,
                    dwellIndicators: computeDwellIndicators(sortedData)
                };
            case 'routeEfficiency':
                return {
                    base,
                    routeEfficiency: computeRouteEfficiency(sortedData)
                };
            default:
                return { base };
        }
    }

    function formatSummaryForPrompt(category, summary) {
        if (summary.status === 'empty') {
            return 'No bus route data is currently loaded on the map.';
        }

        const lines = [];
        const { base } = summary;
        if (base) {
            lines.push(`Total events recorded: ${base.totalEvents}`);
            if (base.timeRange) {
                lines.push(`Observation window: ${base.timeRange.startISO} to ${base.timeRange.endISO} (${base.timeRange.durationMinutes} minutes).`);
            }
            lines.push('Behavior distribution: ' + Object.entries(base.behaviorDistribution).map(([behavior, count]) => `${behavior}=${count}`).join(', '));
        }

        if (category === 'aggressivePatterns' && summary.aggressiveHotspots?.length) {
            lines.push('Aggressive hotspots:');
            summary.aggressiveHotspots.forEach((hotspot, index) => {
                lines.push(`${index + 1}. Cluster ${hotspot.clusterId} at ${hotspot.location} (${hotspot.events} events, average instability ${hotspot.averageInstability}).`);
            });
        }

        if (category === 'dwellTime') {
            if (summary.dwellIndicators?.length) {
                lines.push('Potential dwell periods:');
                summary.dwellIndicators.forEach((entry, index) => {
                    lines.push(`${index + 1}. ${entry.durationMinutes} mins near ${entry.location} before ${entry.timestamp}, resumed as ${entry.resumedBehavior}.`);
                });
            } else {
                lines.push('No extended pauses (>2 minutes) detected between recorded points.');
            }
        }

        if (category === 'routeEfficiency' && summary.routeEfficiency) {
            const r = summary.routeEfficiency;
            lines.push(`Route distance travelled: ${r.traveledDistanceMetres} m.`);
            lines.push(`Straight-line distance start to end: ${r.straightLineMetres} m.`);
            lines.push(`Efficiency ratio (straight/travelled): ${r.efficiencyRatio}.`);
            lines.push(`Start: ${r.startLocation}. End: ${r.endLocation}.`);
        }

        return lines.join('\n');
    }

    function buildPrompt(category, query, dataSummary, extraReplacements = {}) {
        const template = promptTemplates[category] || promptTemplates.generalInfo;
        const replacements = { data: dataSummary, userQuery: query, ...extraReplacements };
        return template.replace(/{{(.*?)}}/g, (_, key) => {
            const token = key.trim();
            return Object.prototype.hasOwnProperty.call(replacements, token) ? replacements[token] : '';
        });
    }

    async function callLLMAPI(prompt) {
        const response = await fetch('/api/generate-summary', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt })
        });

        if (!response.ok) {
            throw new Error('Unable to retrieve analysis from the language model.');
        }

        const data = await response.json();
        const message = data?.choices?.[0]?.message?.content;
        if (!message) {
            throw new Error('Received an empty response from the language model.');
        }
        return message.trim();
    }

    async function processRawMode(query) {
        if (!allData.length) {
            throw new Error('No route data has been loaded yet. Zoom or reload the map to fetch telemetry.');
        }

        // Use the improved splitting function
        const { chunks, truncated, processedCount } = splitFeaturesForRawMode(allData);
        
        if (!chunks.length) {
            throw new Error('Unable to prepare the dataset for analysis.');
        }

        // If we only have one chunk, don't do the chunking flow at all
        if (chunks.length === 1) {
            const singleChunk = chunks[0];
            const chunkJson = JSON.stringify(singleChunk.data);
            
            const prompt = buildPrompt('raw', query, chunkJson);
            const response = await callLLMAPI(prompt);
            
            return {
                response,
                category: 'raw-full',
                dataSummary: `Full optimized dataset (${allData.length} records, ~${Math.round(singleChunk.estimatedTokens)} tokens) sent to model.\n\nCompressed data format with legend included for model interpretation.`
            };
        }

        // For multiple chunks, process each one
        const chunkNotes = [];
        const chunkDescriptors = [];

        for (let i = 0; i < chunks.length; i++) {
            const chunk = chunks[i];
            const chunkJson = JSON.stringify(chunk.data);
            
            chunkDescriptors.push(
                `Chunk ${i + 1}: records ${chunk.startIndex + 1}-${chunk.endIndex + 1} (~${Math.round(chunk.estimatedTokens)} tokens)`
            );

            const chunkResponse = await callLLMAPI(
                buildPrompt('rawChunk', query, chunkJson, {
                    chunkIndex: i + 1,
                    totalChunks: chunks.length
                })
            );
            
            chunkNotes.push(`Chunk ${i + 1} findings:\n${chunkResponse}`);
        }

        // Process the final combined response
        const truncatedNote = truncated
            ? `Only ${processedCount} of ${allData.length} records were processed due to token limits.`
            : `All ${processedCount} records were processed across ${chunks.length} chunks.`;

        const finalPrompt = buildPrompt('rawFinal', query, chunkNotes.join('\n\n'), {
            chunkCount: chunks.length,
            truncatedNote
        });
        
        const finalResponse = await callLLMAPI(finalPrompt);

        const partialNotes = chunkNotes.join('\n\n');
        const dataSummary = `${chunkDescriptors.join('\n')}
${truncated ? `⚠️ ${truncatedNote}` : truncatedNote}

Partial chunk notes forwarded to the final prompt:
${partialNotes}`;

        return { 
            response: finalResponse, 
            category: truncated ? 'raw-chunked-partial' : 'raw-chunked', 
            dataSummary 
        };
    }

    async function processUserQuery(query, mode = 'cluster') {
        if (mode === 'raw') {
            return processRawMode(query);
        }

        const { category } = analyzeUserQuery(query);
        const summary = await fetchRelevantData(category);
        const dataSummary = formatSummaryForPrompt(category, summary);
        const prompt = buildPrompt(category, query, dataSummary);
        const response = await callLLMAPI(prompt);
        return { response, category, dataSummary };
    }

    function renderLoadingState(query, mode) {
        showSummaryModal();
        const modeLabel = mode === 'raw' ? 'Raw' : 'Cluster';
        document.getElementById('summaryHeader').textContent = `Analyzing (${modeLabel} mode): "${query}"`;
    const modeMessage = mode === 'raw' ? 'the full raw dataset (chunking if necessary)…' : 'clustered insights';
    document.getElementById('summaryText').innerHTML = `<p class="loading-message">Processing your question with ${modeMessage}</p>`;
        document.getElementById('feedbackContainer').innerHTML = '';
    }

    function displayResults(query, mode, result) {
        const summaryHeader = document.getElementById('summaryHeader');
        const summaryText = document.getElementById('summaryText');
        const feedbackContainer = document.getElementById('feedbackContainer');

        const modeLabel = mode === 'raw' ? 'Raw' : 'Cluster';
        summaryHeader.textContent = `Result (${modeLabel} mode) for: "${query}"`;
        const dataSummaryLabel = mode === 'raw' ? 'Raw dataset delivery summary' : 'Data summary provided to the model';
        summaryText.innerHTML = `
            <div class="results">
                <div class="response-content">${escapeHtml(result.response)}</div>
                <details>
                    <summary>${escapeHtml(dataSummaryLabel)}</summary>
                    <pre style="white-space: pre-wrap; font-size: 12px; background: #f7f7f7; padding: 10px; border-radius: 6px;">${escapeHtml(result.dataSummary)}</pre>
                </details>
            </div>
        `;

        feedbackContainer.innerHTML = `
            <div class="feedback">
                <span>Was this response helpful?</span>
                <button class="feedback-btn" data-value="yes">Yes</button>
                <button class="feedback-btn" data-value="no">No</button>
            </div>
        `;

        feedbackContainer.querySelectorAll('.feedback-btn').forEach(button => {
            button.addEventListener('click', (event) => {
                const value = event.target.getAttribute('data-value');
                logFeedback(query, result.response, value, mode);
                feedbackContainer.innerHTML = '<div class="feedback">Thanks for the feedback!</div>';
            });
        });
    }

    function handleQueryError(query, mode, error) {
        const summaryHeader = document.getElementById('summaryHeader');
        const summaryText = document.getElementById('summaryText');
        const feedbackContainer = document.getElementById('feedbackContainer');

        const modeLabel = mode === 'raw' ? 'Raw' : 'Cluster';
        summaryHeader.textContent = `Issue while analyzing (${modeLabel} mode): "${query}"`;
        summaryText.innerHTML = `<div class="error-message">${escapeHtml(error.message || 'Something went wrong.')}</div>`;
        feedbackContainer.innerHTML = '';
    }

    function logFeedback(query, response, feedback, mode) {
        console.info('User feedback captured', { query, mode, feedback, responseSnippet: response.slice(0, 120) });
    }

    function attachQueryHandlers() {
        const input = document.getElementById('user-query');
        const button = document.getElementById('submit-query');
        const toggleButton = document.getElementById('context-toggle');
        const modeField = document.getElementById('context-mode');

        if (!input || !button) {
            return;
        }

        const applyModeToToggle = (mode) => {
            if (!toggleButton || !modeField) {
                return;
            }
            modeField.value = mode;
            toggleButton.dataset.mode = mode;
            toggleButton.setAttribute('aria-pressed', mode === 'raw');
            toggleButton.setAttribute('aria-label', `Context mode: ${mode === 'raw' ? 'Raw' : 'Cluster'}`);
        };

        if (toggleButton && modeField) {
            applyModeToToggle(modeField.value || 'cluster');
            toggleButton.addEventListener('click', () => {
                const nextMode = modeField.value === 'cluster' ? 'raw' : 'cluster';
                applyModeToToggle(nextMode);
            });
        }

        button.addEventListener('click', async () => {
            const query = input.value.trim();
            if (!query) {
                input.focus();
                return;
            }
            const mode = getSelectedContextMode();
            renderLoadingState(query, mode);
            try {
                const result = await processUserQuery(query, mode);
                displayResults(query, mode, result);
            } catch (error) {
                console.error('Error processing query:', error);
                handleQueryError(query, mode, error);
            }
        });

        input.addEventListener('keydown', async (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                button.click();
            }
        });
    }

    var baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    // --- Updated Data Configuration for Behavior-Based Clustering ---
    const behaviorTypes = ['Calm', 'Moderate', 'Slightly Unstable', 'Aggressive', 'Very Aggressive'];
    const behaviorColors = {
        'Calm': '#2c7bb6',
        'Moderate': '#abd9e9', 
        'Slightly Unstable': '#ffffbf',
        'Aggressive': '#fdae61',
        'Very Aggressive': '#d7191c'
    };

    // Create an object to hold our layer groups, one for each behavior type
    const overlayLayers = {};
    
    // Create a Layer Group for each behavior type and add it to the map by default
    behaviorTypes.forEach(behavior => {
        const color = behaviorColors[behavior];
        const layerName = `<span style="background-color:${color}; padding: 1px 8px; border-radius: 3px;">&nbsp;</span> ${behavior}`;
        
        // Create an empty layer group for this behavior
        overlayLayers[layerName] = L.layerGroup().addTo(map);
    });

    // --- Data Loading and Processing ---
    fetch('bus_route_with_clusters.geojson')
        .then(response => response.json())
        .then(data => {
            // Store all data points for analysis
            allData = data.features;

            // Process each feature and add it to the correct layer group
            data.features.forEach((feature, index) => {
                const props = feature.properties;
                const behavior = props.behavior;
                const color = props.color;
                
                const marker = L.circleMarker(
                    [feature.geometry.coordinates[1], feature.geometry.coordinates[0]],
                    {
                        radius: 6,
                        fillColor: color,
                        color: "#000",
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8
                    }
                );

                // Build comprehensive popup content
                const popupContent = `
                    <div style="width: 320px; max-height: 400px; overflow-y: auto;">
                        <!-- Header Section -->
                        <div class="popup-section">
                            <div style="text-align: center; margin-bottom: 10px;">
                                <span class="behavior-badge" style="background-color: ${color};">${behavior} Driving</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Timestamp:</span>
                                <span class="data-value">${props.timestamp}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Location:</span>
                                <span class="data-value">${feature.geometry.coordinates[1].toFixed(6)}, ${feature.geometry.coordinates[0].toFixed(6)}</span>
                            </div>
                        </div>

                        <!-- Clustering Analysis Section -->
                        <div class="popup-section">
                            <div class="popup-header">🎯 Clustering Analysis</div>
                            <div class="data-row">
                                <span class="data-label">Cluster ID:</span>
                                <span class="data-value highlight-value">${props.cluster}</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Extreme Event Magnitude:</span>
                                <span class="data-value highlight-value">${props.extreme_event_magnitude.toFixed(4)} m/s²</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Instability Score:</span>
                                <span class="data-value highlight-value">${props.instability_score.toFixed(4)} (m/s²)²</span>
                            </div>
                        </div>

                        <!-- Basic Acceleration Statistics -->
                        <div class="popup-section">
                            <div class="popup-header">📊 Basic Acceleration Statistics</div>
                            <div class="data-row">
                                <span class="data-label">Mean Acceleration:</span>
                                <span class="data-value">${props.accel_mean.toFixed(4)} m/s²</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">Acceleration Variance:</span>
                                <span class="data-value">${props.accel_variance.toFixed(4)} (m/s²)²</span>
                            </div>
                        </div>

                        <!-- X-Axis Acceleration Statistics -->
                        <div class="popup-section">
                            <div class="popup-header">📈 X-Axis Acceleration Percentiles</div>
                            <div class="data-row">
                                <span class="data-label">1st Percentile (p1):</span>
                                <span class="data-value">${props.accel_stats_x_p1.toFixed(4)} m/s²</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">10th Percentile (p10):</span>
                                <span class="data-value">${props.accel_stats_x_p10.toFixed(4)} m/s²</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">90th Percentile (p90):</span>
                                <span class="data-value">${props.accel_stats_y_p90.toFixed(4)} m/s²</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">99th Percentile (p99):</span>
                                <span class="data-value highlight-value">${props.accel_stats_x_p99.toFixed(4)} m/s²</span>
                            </div>
                        </div>

                        <!-- Y-Axis Acceleration Statistics -->
                        <div class="popup-section">
                            <div class="popup-header">📈 Y-Axis Acceleration Percentiles</div>
                            <div class="data-row">
                                <span class="data-label">1st Percentile (p1):</span>
                                <span class="data-value">${props.accel_stats_y_p1.toFixed(4)} m/s²</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">10th Percentile (p10):</span>
                                <span class="data-value">${props.accel_stats_y_p10.toFixed(4)} m/s²</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">90th Percentile (p90):</span>
                                <span class="data-value">${props.accel_stats_y_p90.toFixed(4)} m/s²</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">99th Percentile (p99):</span>
                                <span class="data-value highlight-value">${props.accel_stats_y_p99.toFixed(4)} m/s²</span>
                            </div>
                        </div>

                        <!-- Z-Axis Acceleration Statistics -->
                        <div class="popup-section">
                            <div class="popup-header">📈 Z-Axis Acceleration Percentiles</div>
                            <div class="data-row">
                                <span class="data-label">1st Percentile (p1):</span>
                                <span class="data-value">${props.accel_stats_z_p1.toFixed(4)} m/s²</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">10th Percentile (p10):</span>
                                <span class="data-value">${props.accel_stats_z_p10.toFixed(4)} m/s²</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">90th Percentile (p90):</span>
                                <span class="data-value">${props.accel_stats_z_p90.toFixed(4)} m/s²</span>
                            </div>
                            <div class="data-row">
                                <span class="data-label">99th Percentile (p99):</span>
                                <span class="data-value highlight-value">${props.accel_stats_z_p99.toFixed(4)} m/s²</span>
                            </div>
                        </div>

                        <!-- AI Insight Section -->
                        <div class="popup-section">
                            <div class="popup-header">🤖 AI Insight</div>
                            <div id="ai-insight-${index}" style="font-size: 12px; color: #333; line-height: 1.4; min-height: 40px; padding: 5px; background-color: #f7f7f7; border-radius: 3px;">
                                Click the button for an AI-powered explanation.
                            </div>
                            <button id="ai-insight-btn-${index}" onclick='getAiInsight(${index})' style="margin-top: 10px; padding: 6px 12px; background-color: #2c7bb6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold;">Get AI Insight</button>
                        </div>

                        <!-- Interpretation Section -->
                        <div class="popup-section">
                            <div class="popup-header">🔍 Data Interpretation</div>
                            <div style="font-size: 11px; color: #666; line-height: 1.3;">
                                <strong>Extreme Event Magnitude:</strong> Combined 3D acceleration vector magnitude from 99th percentiles - higher values indicate more severe acceleration events.<br><br>
                                <strong>Instability Score:</strong> Acceleration variance - higher values indicate more erratic or jerky motion.<br><br>
                                <strong>Percentiles:</strong> p1/p10 show typical low values, p90/p99 show extreme high values for each axis.
                            </div>
                        </div>
                    </div>
                `;
                
                marker.bindPopup(popupContent, {
                    maxWidth: 350,
                    maxHeight: 450
                });
                
                // Find the correct layer group by behavior name and add the marker
                const layerKey = Object.keys(overlayLayers).find(key => key.includes(behavior));
                if (layerKey) {
                    overlayLayers[layerKey].addLayer(marker);
                }
            });

            // Fit map to the bounds of all features
            const allPointsLayer = L.geoJSON(data);
            if (allPointsLayer.getBounds().isValid()) {
                map.fitBounds(allPointsLayer.getBounds());
            }
        })
        .catch(error => {
            console.error('Error loading GeoJSON:', error);
            alert('Error loading bus data. Please check that your GeoJSON file is accessible.');
        });

    // Add the layer control panel to the map
    L.control.layers(null, overlayLayers, { collapsed: false }).addTo(map);

    // --- Enhanced Geographic Landmark System ---
    const campusLandmarks = {
        buildings: [
            { name: 'Klaus Advanced Computing Building', center: [33.777, -84.396], radius: 30, type: 'academic' },
            { name: 'Student Center', center: [33.774, -84.3915], radius: 50, type: 'dining' },
            { name: 'CRC (Campus Recreation Center)', center: [33.776, -84.404], radius: 40, type: 'recreation' },
            { name: 'Clough Undergraduate Learning Commons', center: [33.775, -84.3965], radius: 35, type: 'academic' },
            { name: 'Guggenheim Building', center: [33.7755, -84.394], radius: 25, type: 'academic' },
            { name: 'Bobby Dodd Stadium', center: [33.773, -84.395], radius: 60, type: 'athletics' },
            { name: 'North Avenue Apartments', center: [33.772, -84.392], radius: 45, type: 'residential' },
            { name: 'Tech Tower', center: [33.775, -84.396], radius: 20, type: 'administrative' },
            { name: 'Library', center: [33.775, -84.3965], radius: 30, type: 'academic' },
            { name: 'Campus Center', center: [33.774, -84.3915], radius: 40, type: 'dining' },
            { name: 'Howey Physics Building', center: [33.776, -84.395], radius: 25, type: 'academic' },
            { name: 'Van Leer Electrical Engineering Building', center: [33.776, -84.395], radius: 30, type: 'academic' },
            { name: 'College of Computing Building', center: [33.777, -84.396], radius: 25, type: 'academic' },
            { name: 'Skiles Classroom Building', center: [33.775, -84.395], radius: 25, type: 'academic' },
            { name: 'Ferst Center for the Arts', center: [33.774, -84.393], radius: 30, type: 'arts' }
        ],
        intersections: [
            { name: 'Ferst Dr & Atlantic Dr', center: [33.779, -84.397], radius: 25, type: 'traffic' },
            { name: 'North Ave & Techwood Dr', center: [33.771, -84.392], radius: 30, type: 'traffic' },
            { name: 'Ferst Dr & State St', center: [33.775, -84.394], radius: 20, type: 'traffic' },
            { name: 'Ferst Dr & Cherry St', center: [33.773, -84.394], radius: 20, type: 'traffic' },
            { name: '10th St & Hemphill Ave', center: [33.777, -84.389], radius: 25, type: 'traffic' },
            { name: '5th St & Spring St', center: [33.780, -84.385], radius: 25, type: 'traffic' }
        ],
        zones: [
            { name: 'Tech Square District', center: [33.777, -84.389], radius: 150, type: 'commercial' },
            { name: 'West Campus Housing', center: [33.778, -84.401], radius: 200, type: 'residential' },
            { name: 'East Campus', center: [33.776, -84.385], radius: 180, type: 'academic' },
            { name: 'Midtown Area', center: [33.780, -84.385], radius: 120, type: 'commercial' },
            { name: 'Tech Green', center: [33.776, -84.395], radius: 80, type: 'recreation' },
            { name: 'Historic District', center: [33.775, -84.396], radius: 100, type: 'historic' }
        ],
        transportation: [
            { name: 'Tech Trolley Stop - Student Center', center: [33.774, -84.391], radius: 15, type: 'transit' },
            { name: 'MARTA North Avenue Station', center: [33.771, -84.387], radius: 100, type: 'transit' },
            { name: 'Tech Trolley Stop - Tech Square', center: [33.777, -84.389], radius: 15, type: 'transit' },
            { name: 'Tech Trolley Stop - CRC', center: [33.776, -84.404], radius: 15, type: 'transit' },
            { name: 'Bike Share Station - Student Center', center: [33.774, -84.3915], radius: 10, type: 'bikeshare' },
            { name: 'Bike Share Station - Tech Square', center: [33.777, -84.389], radius: 10, type: 'bikeshare' }
        ],
        crosswalks: [
            { name: 'Clough Commons Crosswalk', center: [33.775, -84.3965], radius: 15, type: 'pedestrian' },
            { name: 'Student Center Crosswalk', center: [33.774, -84.3915], radius: 15, type: 'pedestrian' },
            { name: 'Tech Square Crosswalk', center: [33.777, -84.389], radius: 15, type: 'pedestrian' },
            { name: 'Bobby Dodd Crosswalk', center: [33.773, -84.395], radius: 15, type: 'pedestrian' }
        ],
        construction: [
            { name: 'Construction Zone - West Campus', center: [33.778, -84.401], radius: 50, type: 'construction' },
            { name: 'Construction Zone - Tech Square', center: [33.777, -84.389], radius: 40, type: 'construction' }
        ]
    };

    // --- Helper function to calculate distance between two lat-lon points ---
    function getDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // Earth's radius in metres
        const φ1 = lat1 * Math.PI/180;
        const φ2 = lat2 * Math.PI/180;
        const Δφ = (lat2-lat1) * Math.PI/180;
        const Δλ = (lon2-lon1) * Math.PI/180;

        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c; // Distance in metres
    }

    // --- Enhanced Location Context Function ---
    function getEnhancedLocationContext(lat, lon) {
        const contexts = [];
        
        // Check all landmark types in order of specificity
        ['buildings', 'crosswalks', 'intersections', 'transportation', 'construction', 'zones'].forEach(category => {
            campusLandmarks[category].forEach(landmark => {
                const distance = getDistance(lat, lon, landmark.center[0], landmark.center[1]);
                if (distance <= landmark.radius) {
                    contexts.push({
                        name: landmark.name,
                        distance: Math.round(distance),
                        type: landmark.type,
                        category: category
                    });
                }
            });
        });
        
        // Return most specific context available
        if (contexts.length > 0) {
            contexts.sort((a, b) => a.distance - b.distance);
            const primary = contexts[0];
            let contextString = `near ${primary.name}`;
            
            // Add secondary context if relevant and close
            if (contexts.length > 1 && contexts[1].distance < 50) {
                contextString += `, close to ${contexts[1].name}`;
            }
            
            // Add construction context if present
            const constructionContext = contexts.find(c => c.type === 'construction');
            if (constructionContext) {
                contextString += ` (construction zone nearby)`;
            }
            
            return {
                description: contextString,
                primary: primary,
                secondary: contexts.length > 1 ? contexts[1] : null,
                construction: constructionContext,
                all: contexts
            };
        }
        
        return {
            description: 'in an unidentified campus area',
            primary: null,
            secondary: null,
            construction: null,
            all: []
        };
    }

    // --- Temporal Context Enhancement ---
    function getTemporalContext(timestamp) {
        const date = new Date(timestamp);
        const hour = date.getHours();
        const dayOfWeek = date.getDay();
        const month = date.getMonth();
        
        let timeContext = '';
        let trafficContext = '';
        let pedestrianContext = '';
        
        // Time of day context
        if (hour >= 7 && hour <= 9) {
            timeContext = 'during morning rush hour';
            trafficContext = 'heavy commuter traffic';
            pedestrianContext = 'students heading to early classes';
        } else if (hour >= 11 && hour <= 13) {
            timeContext = 'during lunch hours';
            trafficContext = 'moderate traffic with food delivery vehicles';
            pedestrianContext = 'high pedestrian activity for lunch';
        } else if (hour >= 16 && hour <= 18) {
            timeContext = 'during evening rush hour';
            trafficContext = 'heavy commuter traffic';
            pedestrianContext = 'students leaving campus';
        } else if (hour >= 19 && hour <= 23) {
            timeContext = 'during evening hours';
            trafficContext = 'light traffic';
            pedestrianContext = 'students returning from evening activities';
        } else if (hour >= 0 && hour <= 6) {
            timeContext = 'during late night/early morning';
            trafficContext = 'minimal traffic';
            pedestrianContext = 'very few pedestrians';
        } else {
            timeContext = 'during off-peak hours';
            trafficContext = 'moderate traffic';
            pedestrianContext = 'normal pedestrian activity';
        }
        
        // Day context
        if (dayOfWeek >= 1 && dayOfWeek <= 5) {
            timeContext += ' on a weekday';
        } else {
            timeContext += ' on a weekend';
        }
        
        // Academic calendar context (simplified)
        if (month >= 8 || month <= 5) {
            timeContext += ' during academic year';
        } else {
            timeContext += ' during summer break';
        }
        
        return {
            timeDescription: timeContext,
            trafficLevel: trafficContext,
            pedestrianActivity: pedestrianContext,
            hour: hour,
            dayOfWeek: dayOfWeek,
            isWeekday: dayOfWeek >= 1 && dayOfWeek <= 5,
            isRushHour: (hour >= 7 && hour <= 9) || (hour >= 16 && hour <= 18)
        };
    }

    // --- Validation and Grounding System ---
    function validateInsight(insight, eventData, locationContext) {
        const validationRules = {
            // Check if response mentions location correctly
            locationMention: locationContext.primary ? locationContext.primary.name.toLowerCase() : 'campus',
            
            // Validate behavior classification consistency
            behaviorConsistency: eventData.behavior.toLowerCase(),
            
            // Check for hallucinated landmarks
            knownLandmarks: Object.values(campusLandmarks).flat().map(b => b.name.toLowerCase()),
            
            // Check for reasonable length
            maxLength: 100,
            minLength: 20
        };
        
        const issues = [];
        const insightLower = insight.toLowerCase();
        
        // Length validation
        if (insight.length > validationRules.maxLength) {
            issues.push('Response is too long');
        }
        if (insight.length < validationRules.minLength) {
            issues.push('Response is too short');
        }
        
        // Location validation
        if (locationContext.primary && !insightLower.includes(validationRules.locationMention)) {
            issues.push('Response does not reference the correct location');
        }
        
        // Behavior consistency
        if (!insightLower.includes(validationRules.behaviorConsistency)) {
            issues.push('Response does not align with classified behavior');
        }
        
        // Check for hallucinated landmarks
        const mentionedLandmarks = insightLower.match(/\b[a-z\s]+(?:building|center|station|stop|crosswalk|intersection)\b/g) || [];
        const unknownLandmarks = mentionedLandmarks.filter(landmark => 
            !validationRules.knownLandmarks.some(known => known.includes(landmark.trim()))
        );
        
        if (unknownLandmarks.length > 0) {
            issues.push(`Mentions unknown landmarks: ${unknownLandmarks.join(', ')}`);
        }
        
        // Content quality checks
        if (insightLower.includes('i apologize') || insightLower.includes('i cannot')) {
            issues.push('Response contains apology or refusal language');
        }
        
        if (insightLower.includes('as an ai') || insightLower.includes('language model')) {
            issues.push('Response contains AI self-reference');
        }
        
        return {
            isValid: issues.length === 0,
            issues: issues,
            confidence: Math.max(0, 1 - (issues.length * 0.2)),
            score: Math.max(0, 100 - (issues.length * 20))
        };
    }

    // --- Enhanced Neighbor Analysis ---
    function getEnhancedNeighborAnalysis(lat, lon, radius = 100) {
        const neighbors = allData.filter((otherFeature, i) => {
            const [otherLon, otherLat] = otherFeature.geometry.coordinates;
            return getDistance(lat, lon, otherLat, otherLon) <= radius;
        });

        if (neighbors.length === 0) {
            return {
                count: 0,
                summary: 'No other events detected nearby.',
                behaviorDistribution: {},
                temporalPattern: null,
                spatialPattern: null
            };
        }

        // Behavior distribution
        const behaviorCounts = neighbors.reduce((acc, curr) => {
            const behavior = curr.properties.behavior;
            acc[behavior] = (acc[behavior] || 0) + 1;
            return acc;
        }, {});

        // Temporal pattern analysis
        const timeSlots = neighbors.map(n => {
            const hour = new Date(n.properties.timestamp).getHours();
            return hour >= 7 && hour <= 9 ? 'morning' : 
                   hour >= 11 && hour <= 13 ? 'lunch' :
                   hour >= 16 && hour <= 18 ? 'evening' : 'other';
        });
        const temporalPattern = timeSlots.reduce((acc, slot) => {
            acc[slot] = (acc[slot] || 0) + 1;
            return acc;
        }, {});

        // Spatial pattern (distance distribution)
        const distances = neighbors.map(n => {
            const [otherLon, otherLat] = n.geometry.coordinates;
            return getDistance(lat, lon, otherLat, otherLon);
        });
        const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;

        const summaryParts = Object.entries(behaviorCounts).map(([b, c]) => `${c} ${b}`);
        const summary = `The immediate area (${radius}m radius) contains ${neighbors.length} other event(s): ${summaryParts.join(', ')}.`;

        return {
            count: neighbors.length,
            summary: summary,
            behaviorDistribution: behaviorCounts,
            temporalPattern: temporalPattern,
            spatialPattern: {
                averageDistance: Math.round(avgDistance),
                closestDistance: Math.round(Math.min(...distances)),
                furthestDistance: Math.round(Math.max(...distances))
            }
        };
    }

    // --- Legacy function for backward compatibility ---
    function getZoneName(lat, lon) {
        const context = getEnhancedLocationContext(lat, lon);
        return context.primary ? context.primary.name : 'an un-named area';
    }

    // --- Cross-Referencing with Known Campus Features ---
    function getCampusFeatureContext(locationContext, temporalContext) {
        const insights = [];
        
        // Cross-reference location type with temporal patterns
        if (locationContext.primary) {
            const locationType = locationContext.primary.type;
            const isRushHour = temporalContext.isRushHour;
            const isWeekday = temporalContext.isWeekday;
            
            // Academic buildings during class hours
            if (locationType === 'academic' && isWeekday && temporalContext.hour >= 8 && temporalContext.hour <= 17) {
                insights.push('High student pedestrian traffic between classes');
            }
            
            // Dining areas during meal times
            if (locationType === 'dining' && (temporalContext.hour >= 11 && temporalContext.hour <= 14 || temporalContext.hour >= 17 && temporalContext.hour <= 19)) {
                insights.push('Food delivery vehicles and student meal traffic');
            }
            
            // Transit stops during peak hours
            if (locationType === 'transit' && isRushHour) {
                insights.push('Bus and trolley traffic with passenger loading/unloading');
            }
            
            // Construction zones
            if (locationContext.construction) {
                insights.push('Construction-related traffic and lane closures');
            }
            
            // Crosswalks and pedestrian areas
            if (locationType === 'pedestrian') {
                insights.push('Pedestrian crossing activity');
            }
        }
        
        return insights.length > 0 ? insights.join('; ') : 'Normal campus traffic patterns';
    }

    // --- Enhanced Response Quality Assurance ---
    function enhanceResponseQuality(insight, eventData, locationContext, temporalContext) {
        let enhancedInsight = insight;
        
        // Add missing location context if not present
        if (locationContext.primary && !insight.toLowerCase().includes(locationContext.primary.name.toLowerCase())) {
            enhancedInsight = `Near ${locationContext.primary.name}: ${enhancedInsight}`;
        }
        
        // Add temporal context if missing
        if (!insight.toLowerCase().includes('morning') && !insight.toLowerCase().includes('evening') && 
            !insight.toLowerCase().includes('lunch') && !insight.toLowerCase().includes('rush')) {
            if (temporalContext.isRushHour) {
                enhancedInsight = enhancedInsight.replace(/\.$/, '') + ` during ${temporalContext.timeDescription.split(' ')[1]} rush hour.`;
            }
        }
        
        // Add campus-specific context
        const campusContext = getCampusFeatureContext(locationContext, temporalContext);
        if (!enhancedInsight.toLowerCase().includes('student') && !enhancedInsight.toLowerCase().includes('pedestrian')) {
            if (campusContext.includes('student') || campusContext.includes('pedestrian')) {
                enhancedInsight = enhancedInsight.replace(/\.$/, '') + ` This is typical for ${campusContext.toLowerCase()}.`;
            }
        }
        
        return enhancedInsight;
    }

    // --- Retry Logic for Low-Quality Responses ---
    async function retryInsightGeneration(prompt, maxRetries = 2) {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch('/api/generate-insight', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        prompt: prompt + `\n\nAttempt ${attempt}: Please ensure your response is specific to the location and time mentioned.`
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to get AI insight from server.');
                }

                const data = await response.json();
                return data.choices[0].message.content;
                
            } catch (error) {
                console.error(`Attempt ${attempt} failed:`, error);
                if (attempt === maxRetries) {
                    throw error;
                }
                // Wait before retry
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
    }

    // Add these functions for summary generation
    function showSummaryModal() {
        document.getElementById('modalOverlay').style.display = 'block';
        document.getElementById('summaryModal').style.display = 'block';
    }

    function closeSummary() {
        document.getElementById('modalOverlay').style.display = 'none';
        document.getElementById('summaryModal').style.display = 'none';
    }

    async function getAiInsight(index) {
        const feature = allData[index];
        const props = feature.properties;
        const insightContainer = document.getElementById(`ai-insight-${index}`);
        const insightButton = document.getElementById(`ai-insight-btn-${index}`);

        if (!feature) {
            insightContainer.innerHTML = 'Error: Data not found.';
            return;
        }

        insightButton.disabled = true;
        insightButton.textContent = 'Analyzing...';
        insightContainer.innerHTML = 'Generating AI insight, please wait...';

        // --- Enhanced Context Generation ---
        const [lon, lat] = feature.geometry.coordinates;
        const locationContext = getEnhancedLocationContext(lat, lon);
        const temporalContext = getTemporalContext(props.timestamp);
        const neighborAnalysis = getEnhancedNeighborAnalysis(lat, lon, 100);

        // --- Enhanced, Context-Rich Prompt with Validation ---
        const prompt = `
            You are a transportation safety analyst providing a concise, 50-word summary for a specific driving event on the Georgia Tech campus. Your summary must be a single block of plaintext with no special formatting.

            Campus Context: Georgia Tech is an active urban campus with heavy pedestrian traffic, construction zones, and multiple transportation modes (buses, cars, bikes, scooters).

            Event Details:
            - Behavior Classification: '${props.behavior}'
            - Location: ${locationContext.description}
            - Temporal Context: ${temporalContext.timeDescription}
            - Traffic Level: ${temporalContext.trafficLevel}
            - Pedestrian Activity: ${temporalContext.pedestrianActivity}
            - Technical Metrics: Instability ${props.instability_score.toFixed(2)}, 
              Peak accelerations X: ${props.accel_stats_x_p99.toFixed(2)} m/s², Y: ${props.accel_stats_y_p99.toFixed(2)} m/s², Z: ${props.accel_stats_z_p99.toFixed(2)} m/s²

            Neighborhood Context: ${neighborAnalysis.summary}

            Campus Feature Context: ${getCampusFeatureContext(locationContext, temporalContext)}

            Provide a 50-word explanation that:
            1. Describes what likely happened (e.g., "sudden braking", "sharp turn")
            2. Explains WHY it happened given the location and time
            3. Uses familiar campus landmarks and student behavior patterns
            4. References the specific location mentioned above

            Write in plain, everyday language that anyone can understand.
        `;
        try {
            let insight;

            const response = await fetch('/api/generate-insight', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt })
            });

            if (!response.ok) {
                throw new Error('Failed to get AI insight from server.');
            }

            const data = await response.json();
            insight = data.choices[0].message.content;

            // --- Validation and Quality Assurance ---
            const validation = validateInsight(insight, props, locationContext);
            
            // If validation fails and score is low, try retry logic
            if (!validation.isValid && validation.score < 60) {
                console.warn('Low quality response detected, attempting retry...');
                try {
                    insight = await retryInsightGeneration(prompt, 1);
                    // Re-validate after retry
                    const retryValidation = validateInsight(insight, props, locationContext);
                    if (retryValidation.score > validation.score) {
                        validation.score = retryValidation.score;
                        validation.isValid = retryValidation.isValid;
                        validation.issues = retryValidation.issues;
                    }
                } catch (retryError) {
                    console.warn('Retry failed, using original response:', retryError);
                }
            }

            // --- Response Quality Enhancement ---
            insight = enhanceResponseQuality(insight, props, locationContext, temporalContext);

            // Display insight with validation feedback if needed
            let displayContent = insight;
            if (!validation.isValid && validation.score < 60) {
                displayContent = `<div style="color: #d7191c; font-size: 11px; margin-bottom: 5px;">⚠️ Low confidence response</div>${insight}`;
            } else if (validation.score >= 80) {
                displayContent = `<div style="color: #28a745; font-size: 11px; margin-bottom: 5px;">✓ High confidence response</div>${insight}`;
            }

            insightContainer.innerHTML = displayContent;
            insightButton.style.display = 'none'; // Hide button after success

        } catch (error) {
            console.error('Error getting AI insight:', error);
            insightContainer.innerHTML = 'Sorry, unable to generate an insight at this time. Please try again later.';
            insightButton.disabled = false;
            insightButton.textContent = 'Get AI Insight';
        }
    }

    async function generateSummary() {
        showSummaryModal();
        const summaryText = document.getElementById('summaryText');
        summaryText.innerHTML = 'Generating summary...';

        try {
            // --- Enhanced: Client-side aggregation with temporal and spatial analysis ---
            const clusters = allData.reduce((acc, feature) => {
                const clusterId = feature.properties.cluster;
                if (!acc[clusterId]) {
                    acc[clusterId] = { 
                        points: [], 
                        behaviors: {}, 
                        instability: 0,
                        timestamps: [],
                        locations: []
                    };
                }
                acc[clusterId].points.push(feature);
                acc[clusterId].timestamps.push(feature.properties.timestamp);
                acc[clusterId].locations.push(feature.geometry.coordinates);
                
                const behavior = feature.properties.behavior;
                acc[clusterId].behaviors[behavior] = (acc[clusterId].behaviors[behavior] || 0) + 1;
                acc[clusterId].instability += feature.properties.instability_score;
                return acc;
            }, {});

            const clusterAnalysis = Object.entries(clusters).map(([id, data]) => {
                const totalPoints = data.points.length;
                const avgInstability = data.instability / totalPoints;
                const dominantBehavior = Object.keys(data.behaviors).reduce((a, b) => data.behaviors[a] > data.behaviors[b] ? a : b);
                const aggressiveCount = (data.behaviors['Aggressive'] || 0) + (data.behaviors['Very Aggressive'] || 0);
                
                // Enhanced severity score: combination of aggressive acts, instability, and temporal clustering
                const severity = aggressiveCount * avgInstability; 
                const [lon, lat] = data.points[0].geometry.coordinates;
                
                // Temporal analysis
                const timeSlots = data.timestamps.map(ts => {
                    const hour = new Date(ts).getHours();
                    return hour >= 7 && hour <= 9 ? 'morning' : 
                           hour >= 11 && hour <= 13 ? 'lunch' :
                           hour >= 16 && hour <= 18 ? 'evening' : 'other';
                });
                const temporalPattern = timeSlots.reduce((acc, slot) => {
                    acc[slot] = (acc[slot] || 0) + 1;
                    return acc;
                }, {});
                
                // Find the closest landmark (always, even if not within radius)
                let closestLandmark = null;
                let closestDistance = Infinity;
                Object.values(campusLandmarks).flat().forEach(landmark => {
                    const distance = getDistance(lat, lon, landmark.center[0], landmark.center[1]);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestLandmark = landmark;
                    }
                });
                let locationPhrase = '';
                if (closestLandmark) {
                    if (closestDistance <= (closestLandmark.radius || 50)) {
                        locationPhrase = `at ${closestLandmark.name}`;
                    } else if (closestDistance < 100) {
                        locationPhrase = `just outside ${closestLandmark.name}`;
                    } else {
                        locationPhrase = `near ${closestLandmark.name}`;
                    }
                } else {
                    locationPhrase = 'somewhere on campus';
                }

                return {
                    id,
                    totalPoints,
                    avgInstability,
                    dominantBehavior,
                    aggressiveCount,
                    severity,
                    temporalPattern,
                    locationPhrase,
                    landmarkType: closestLandmark ? closestLandmark.type : 'unknown',
                    landmarkName: closestLandmark ? closestLandmark.name : ''
                };
            });
            
            // Sort by severity and take top 3
            clusterAnalysis.sort((a, b) => b.severity - a.severity);
            const topAreas = clusterAnalysis.slice(0, 3);
            
            // --- Narrative Data Preparation ---
            const areaNarratives = topAreas.map((area, i) => {
                const temporalInfo = Object.entries(area.temporalPattern)
                    .sort((a, b) => b[1] - a[1])
                    .map(([time, count]) => `${count} ${time}`)
                    .join(', ');
                return `In the area ${area.locationPhrase}, there were ${area.totalPoints} notable moments, most often described as '${area.dominantBehavior.toLowerCase()}' driving. About ${Math.round(area.aggressiveCount/area.totalPoints*100)}% of these were more aggressive. Most activity happened during ${temporalInfo.replace(/,/g, ' and ')}.`;
            });

            // --- Narrative Prompt ---
            const prompt = `You are a campus transportation observer writing a 200-word, single-paragraph, narrative summary for Georgia Tech officials. Your job is to describe the overall driving patterns on campus, referencing real campus places (never say 'unknown' or 'hotspot').

Write in smooth, natural, everyday language. Do not use lists, bullet points, or headings. Do not use technical terms like 'cluster', 'hotspot', 'event', or 'instability'. Instead, tell a story about what the driving is like in different parts of campus, always relating each area to a real Georgia Tech landmark. If an area is not exactly at a landmark, say it is 'near' or 'just outside' the closest known place. Make the report sound like a campus observer, not a chatbot. The text should be plain, with no formatting or special characters.

Here are the key observations to weave into your story:
${areaNarratives.join('\n')}

Begin your narrative now:
`;

            const response = await fetch('/api/generate-summary', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ prompt })
            });

            if (!response.ok) {
                throw new Error('Failed to generate summary');
            }

            const data = await response.json();
            const summary = data.choices[0].message.content;
            
            // Display the summary as plain text (no HTML formatting)
            summaryText.textContent = summary;
        } catch (error) {
            console.error('Error generating summary:', error);
            summaryText.innerHTML = `
                <div style="color: #d7191c; padding: 10px; background-color: #f8d7da; border-radius: 4px;">
                    <p>Failed to generate summary. Please try again later.</p>
                    <p style="font-size: 0.9em;">Error: ${error.message}</p>
                </div>
            `;
        }
    }

    attachQueryHandlers();
</script>

</body>
</html> 